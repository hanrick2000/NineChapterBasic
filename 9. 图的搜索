137. Clone Graph
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     ArrayList<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
//BFS, use queue 

public class Solution {
    /*
     * @param node: A undirected graph node
     * @return: A undirected graph node
     */
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        // write your code here
        if(node == null){
            return null;
        }
        
        HashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();
        Queue<UndirectedGraphNode> queue = new LinkedList<>();
        
        UndirectedGraphNode newnode = new UndirectedGraphNode(node.label);
        
        map.put(node, newnode);
        queue.offer(node);
        while(!queue.isEmpty()){
            UndirectedGraphNode top = queue.poll();
            List<UndirectedGraphNode> neighbors = top.neighbors;
            
            for(UndirectedGraphNode neighbor : neighbors){
                if(!map.containsKey(neighbor)){
                    UndirectedGraphNode newneighbor = new UndirectedGraphNode(neighbor.label);
                    map.put(neighbor, newneighbor);
                    queue.offer(neighbor);
                }
                map.get(top).neighbors.add(map.get(neighbor));
            }
        }
        return newnode;
    }
}

105. Copy List with Random Pointer
/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    /**
     * @param head: The head of linked list with a random pointer.
     * @return: A new head of a deep copy of the list.
     */
    public RandomListNode copyRandomList(RandomListNode head) {
        // write your code here
        if (head == null) {
            return head;
        }
        
        Map<RandomListNode, RandomListNode> hashmap = new HashMap<>();
        
        RandomListNode dummy = new RandomListNode(0);
        dummy.next = head;
        
        // copy nodes
        while (head != null) {
            hashmap.put(head, new RandomListNode(head.label));
            head = head.next;
        }
        
        // copy links
        head = dummy.next;
        while (head != null) {
            hashmap.get(head).next = hashmap.get(head.next);
            hashmap.get(head).random = hashmap.get(head.random);
            head = head.next;
        }
        
        return hashmap.get(dummy.next);
    }
}

127. Topological Sorting
//注意看一下如何构建图的结构， 有的面试会涉及到
/**
 * Definition for Directed graph.
 * class DirectedGraphNode {
 *     int label;
 *     ArrayList<DirectedGraphNode> neighbors;
 *     DirectedGraphNode(int x) { label = x; neighbors = new ArrayList<DirectedGraphNode>(); }
 * };
 */

public class Solution {
    /*
     * @param graph: A list of Directed graph node
     * @return: Any topological order for the given graph.
     */
    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        // write your code here
        ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();
        HashMap<DirectedGraphNode, Integer> map = new HashMap();
        for (DirectedGraphNode node : graph) {//统计入度
            for (DirectedGraphNode neighbor : node.neighbors) {
                if (map.containsKey(neighbor)) {
                    map.put(neighbor, map.get(neighbor) + 1);
                } else {
                    map.put(neighbor, 1); 
                }
            }
        }
        Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        for (DirectedGraphNode node : graph) {
            if (!map.containsKey(node)) {//入度为0的最先进入
                q.offer(node);
                result.add(node);
            }
        }
        while (!q.isEmpty()) {
            DirectedGraphNode node = q.poll();
            for (DirectedGraphNode n : node.neighbors) {
                map.put(n, map.get(n) - 1);
                if (map.get(n) == 0) {
                    result.add(n);
                    q.offer(n);
                }
            }
        }
        return result;
    }
}
//DFS版本
public class Solution {
    /*
     * @param graph: A list of Directed graph node
     * @return: Any topological order for the given graph.
     */
    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        Map<DirectedGraphNode, Integer> indegree = new HashMap<>();
        for (DirectedGraphNode node : graph) {
            indegree.put(node, 0);
        }
        
        for (DirectedGraphNode node : graph) {
            for (DirectedGraphNode neighbor : node.neighbors) {
                indegree.put(neighbor, indegree.get(neighbor) + 1);
            }
        }
        
        ArrayList<DirectedGraphNode> result = new ArrayList<>();
        DirectedGraphNode root = null;
        while ((root = get0IndegreeNode(indegree)) != null) {
            result.add(root);
            dfs(result, indegree, root);
        }
        return result;
    }
    
    DirectedGraphNode get0IndegreeNode(Map<DirectedGraphNode, Integer> indegree) {
        for (Map.Entry<DirectedGraphNode, Integer> entry : indegree.entrySet()) {
            if (entry.getValue() == 0) {
                return entry.getKey();
            }
        }
        return null;
    }
    
    void dfs(List<DirectedGraphNode> result, Map<DirectedGraphNode, Integer> indegree, DirectedGraphNode root) {
        indegree.put(root, -1);//入度已经为0的val置为-1，免得下次又进入递归去
        for (DirectedGraphNode neighbor : root.neighbors) {
            indegree.put(neighbor, indegree.get(neighbor) - 1);
            if (indegree.get(neighbor) == 0) {
                result.add(neighbor);
                dfs(result, indegree, neighbor);
            }
        }
    }
}

15. Permutations
public class Solution {
    /*
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public List<List<Integer>> permute(int[] nums) {
        // write your code here
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null){
            return res;
        }
        if(nums.length == 0){
            res.add(new ArrayList<Integer>());
            return res;
        }
        List<Integer> temp = new ArrayList<Integer>();
        Set<Integer> set = new HashSet<>();
        dfs(res, nums, set, temp);
        return res;
    }
    public void dfs(List<List<Integer>> res, int[] nums, Set<Integer>set, List<Integer>temp){
        if(temp.size() == nums.length){
            res.add(new ArrayList<>(temp));
            return;
        }
        
        for(int i = 0; i < nums.length; i++){
            if (set.contains(nums[i])) {// make sure next loop won't add same number
                continue;
            }
            set.add(nums[i]);
            temp.add(nums[i]);
            dfs(res, nums, set, temp);
            set.remove(nums[i]);
            temp.remove(temp.size() - 1);
        }
    }
}

17. Subsets
class Solution {
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        
        if (nums == null) {
            return results;
        }
        
        if (nums.length == 0) {
            results.add(new ArrayList<Integer>());
            return results;
        }
        
        Arrays.sort(nums);
        helper(new ArrayList<Integer>(), nums, 0, results);
        return results;
    }
    
    
    // 递归三要素
    // 1. 递归的定义：在 Nums 中找到所有以 subset 开头的的集合，并放到 results
    private void helper(ArrayList<Integer> subset,
                        int[] nums,
                        int startIndex,
                        List<List<Integer>> results) {
        // 2. 递归的拆解
        // deep copy
        // results.add(subset);
        results.add(new ArrayList<Integer>(subset));
        
        for (int i = startIndex; i < nums.length; i++) {
            // [1] -> [1,2]
            subset.add(nums[i]);
            // 寻找所有以 [1,2] 开头的集合，并扔到 results
            helper(subset, nums, i + 1, results);
            // [1,2] -> [1]  回溯
            subset.remove(subset.size() - 1);
        }
        
        // 3. 递归的出口
        // return;
    }
}

33. N-Queens
public class Solution {
    /*
     * @param n: The number of queens
     * @return: All distinct solutions
     */
    public List<List<String>> solveNQueens(int n) {
        // write your code here
        List<List<String>> res = new ArrayList<>();
        if(n <= 0){
            return res;
        }
        //colval[] row represents x, column represents y
        int[] colval = new int[n];
        dfs(n, res, 0, colval);
        return res;
    }
    public void dfs(int n, List<List<String>> res, int row, int[] colval){
        //current row equal to n queen, success
        if(row == n){
            List<String> unit = new ArrayList<>();
            for(int i = 0; i < n; i++){
                StringBuilder sb = new StringBuilder();
                for(int j = 0; j < n; j++){
                    if(colval[i] == j){
                        sb.append('Q');
                    } else{
                        sb.append('.');
                    }
                }
                unit.add(sb.toString());
            }
            res.add(unit);
            return;
        } 
        for(int i = 0; i < n; i++){
            colval[row] = i;//iterative, until satisfise the condition
            if(isValid(row, colval)){
                dfs(n, res, row + 1, colval);
            }
        }
    }
    public boolean isValid(int row, int[] colval){
        for(int i = 0; i < row; i++){
            if(colval[row] == colval[i] || Math.abs(colval[row] - colval[i]) == row - i){//not diagnial and same column
                return false;
            }
        }
        return true;
    }
}

18. Subsets II
public class Solution {
    /**
     * @param nums: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // write your code here
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null){
            return res;
        }
        if(nums.length == 0){
            res.add(new ArrayList<>());//list.add的返回值为boolean类型，所以不能直接return。
            return res;
        }
        Arrays.sort(nums);
        List<Integer> list = new ArrayList<>();
        dfs(res, list, nums, 0);
        return res;
    }
    public void dfs(List<List<Integer>> res, List<Integer> list, int[] nums, int startIndex){
        res.add(new ArrayList<>(list));
        for(int i = startIndex; i < nums.length; i++){
            if(i != startIndex && nums[i] == nums[i - 1]){
                continue;
            }
            list.add(nums[i]);
            dfs(res, list, nums, i + 1);
            list.remove(list.size() - 1);
            
        }
    }
}

136. Palindrome Partitioning
public class Solution {
    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    public List<List<String>> partition(String s) {
        List<List<String>> results = new ArrayList<>();
        if (s == null || s.length() == 0) {
            return results;
        }
        
        List<String> partition = new ArrayList<String>();
        helper(s, 0, partition, results);
        
        return results;
    }
    
    public void helper(String s,
                        int startIndex,
                        List<String> partition,
                        List<List<String>> results) {
        if (startIndex == s.length()) {
            results.add(new ArrayList<String>(partition));
            return;
        }
        
        for (int i = startIndex; i < s.length(); i++) {
            String subString = s.substring(startIndex, i + 1);
            if (!isPalindrome(subString)) {
                continue;
            }
            partition.add(subString);
            helper(s, i + 1, partition, results);
            partition.remove(partition.size() - 1);
        }
    }
    
    public boolean isPalindrome(String s) {
        for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}

135. Combination Sum
public class Solution {
    public  List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        if (candidates == null) {
            return result;
        }

        List<Integer> combination = new ArrayList<>();
        Arrays.sort(candidates);
        helper(candidates, 0, target, combination, result);

        return result;
    }

     void helper(int[] candidates,
                 int index,
                 int target,
                 List<Integer> combination,
                 List<List<Integer>> result) {
        if (target == 0) {
            result.add(new ArrayList<Integer>(combination));
            return;
        }

        for (int i = index; i < candidates.length; i++) {
            if (candidates[i] > target) {
                break;
            }

            if (i != 0 && candidates[i] == candidates[i - 1]) {
                continue;
            }

            combination.add(candidates[i]);
            helper(candidates, i, target - candidates[i], combination, result);
            combination.remove(combination.size() - 1);
        }
    }
}

153. Combination Sum II
public class Solution {
    /**
     * @param num: Given the candidate numbers
     * @param target: Given the target number
     * @return: All the combinations that sum to target
     */
    public List<List<Integer>> combinationSum2(int[] candidates,
            int target) {
        List<List<Integer>> results = new ArrayList<>();
        if (candidates == null || candidates.length == 0) {
            return results;
        }

        Arrays.sort(candidates);
        List<Integer> combination = new ArrayList<Integer>();
        helper(candidates, 0, combination, target, results);

        return results;
    }

    private void helper(int[] candidates,
                        int startIndex,
                        List<Integer> combination,
                        int target,
                        List<List<Integer>> results) {
        if (target == 0) {
            results.add(new ArrayList<Integer>(combination));
            return;
        }

        for (int i = startIndex; i < candidates.length; i++) {
            if (i != startIndex && candidates[i] == candidates[i - 1]) {
                continue;
            }
            if (target < candidates[i]) {
                break;
            }
            combination.add(candidates[i]);
            helper(candidates, i + 1, combination, target - candidates[i], results);
            combination.remove(combination.size() - 1);
        }
    }
}
